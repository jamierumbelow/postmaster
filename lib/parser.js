// Generated by CoffeeScript 1.3.1
var mimelib;

mimelib = require('mimelib');

exports.Parser = (function() {
  var COMMANDS;

  Parser.name = 'Parser';

  function Parser() {}

  COMMANDS = ['HELO', 'EHLO', 'MAIL FROM', 'RCPT TO', 'DATA', 'RSET', 'NOOP', 'QUIT', 'HELP'];

  Parser.prototype.parseLine = function(string) {
    var args, command, meaning;
    command = '';
    COMMANDS.forEach(function(cmd) {
      if ((new RegExp("^" + cmd, 'm')).test(string)) {
        return command = cmd;
      }
    });
    if (command === '') {
      command = 'WTF';
    }
    if (this["parse" + (command.replace(' ', ''))] != null) {
      args = this["parse" + (command.replace(' ', ''))](string);
    }
    meaning = args.meaning;
    delete args['meaning'];
    return {
      command: command,
      args: args,
      meaning: meaning
    };
  };

  Parser.prototype.parseHELO = function(string) {
    return {
      domain: string.match(/^(HELO|EHLO) (.*)$/m)[2],
      meaning: 'hello'
    };
  };

  Parser.prototype.parseEHLO = function(string) {
    return this.parseHELO(string);
  };

  Parser.prototype.parseMAILFROM = function(string) {
    return {
      email: string.match(/^MAIL FROM:<(.*)>$/m)[1],
      meaning: 'from'
    };
  };

  Parser.prototype.parseRCPTTO = function(string) {
    return {
      email: string.match(/^RCPT TO:<(.*)>$/m)[1],
      meaning: 'to'
    };
  };

  Parser.prototype.parseDATA = function(string) {
    return {
      meaning: 'data-start'
    };
  };

  Parser.prototype.parseRSET = function(string) {
    return {
      meaning: 'reset'
    };
  };

  Parser.prototype.parseNOOP = function(string) {
    return {
      meaning: 'ping'
    };
  };

  Parser.prototype.parseQUIT = function(string) {
    return {
      meaning: 'quit'
    };
  };

  Parser.prototype.parseHELP = function(string) {
    return {
      meaning: 'info'
    };
  };

  Parser.prototype.parseWTF = function(string) {
    return {
      meaning: 'wtf'
    };
  };

  Parser.prototype.dataCollection = function(string) {
    return {
      meaning: 'data-collection'
    };
  };

  Parser.prototype.parseEmail = function(email) {
    var body, h, headers, match, unparsed_headers, _i, _len, _ref;
    _ref = email.explode("\n\n", 2), unparsed_headers = _ref[0], body = _ref[1];
    unparsed_headers = unparsed_headers.split("\n");
    headers = {};
    for (_i = 0, _len = unparsed_headers.length; _i < _len; _i++) {
      h = unparsed_headers[_i];
      match = h.match(/^([A-Za-z0-9\-_]+): (.*)$/im);
      if (match) {
        headers[match[1]] = match[2];
      }
    }
    return {
      headers: headers,
      body: body,
      html: (headers['Content-Type'] != null ? !!headers['Content-Type'].match(/html/i) : false),
      subject: (headers['Subject'] ? this.parseSubject(headers['Subject']) : false)
    };
  };

  Parser.prototype.parseSubject = function(header) {
    return mimelib.decodeMimeWord(header);
  };

  return Parser;

})();

String.prototype.explode = function(delimiter, limit) {
  var array, splitted, superfluous;
  splitted = this.split(delimiter);
  array = splitted.splice(0, limit - 1);
  superfluous = splitted.join(delimiter);
  array.push(superfluous);
  return array;
};
